---
name: tdd-skill
description: |
  テスト駆動開発（TDD）とKISS原則に従って、高品質で保守性の高いコードを書くためのスキル。
  このスキルは、Red-Green-Refactorサイクルを厳密に実践し、テスト計画から実装、リファクタリングまでの全プロセスをガイドします。
  プロジェクトの既存のコードスタイル、命名規則、アーキテクチャパターンに従いながら、TDDの原則を適用します。
---

# テスト駆動開発（TDD）スキル

このスキルは、テスト駆動開発（TDD）とKISS原則に従って、高品質で保守性の高いコードを書くことを支援します。

## 【開始前の準備】

### プロジェクト適応ガイドライン

開発を始める前に以下を確認してください：

1. **プロジェクトツールの特定**: プロジェクトのテストフレームワーク、ビルドツール、開発環境を決定
2. **規約の理解**: 既存のコードパターン、命名規則、プロジェクト構造をレビュー
3. **コマンドの適応**: 一般的な例（`npm test`、`npm run build`など）の代わりにプロジェクト固有のコマンドを使用
   - **テストコマンド**: プロジェクトの実際のテスト実行コマンド（例: `npm test`、`cargo test`、`go test`、`pytest`など）
   - **ビルドコマンド**: プロジェクトの実際のビルドコマンド（例: `npm run build`、`cargo build`、`go build`など）
   - **リントコマンド**: プロジェクトの実際のリントコマンド（例: `npm run lint`、`cargo clippy`、`golangci-lint run`など）
   - **カバレッジコマンド**: プロジェクトの実際のカバレッジ測定コマンド（例: `npm run test:coverage`、`cargo tarpaulin`、`go test -cover`など）
4. **標準に従う**: プロジェクトのドキュメント、エラーハンドリング、コーディング標準を尊重
5. **一貫性の維持**: 新しいコードが既存のプロジェクトパターンに従うことを確認

**原則**: TDD はプログラミング言語、フレームワーク、プラットフォームに関係なく適用可能。プロジェクトの既存のコードスタイル、命名規則、アーキテクチャパターンに従う。

### TDD コンプライアンス検証

タスクを進める前に、以下を確認してください：

- テスト観点表を作成し、失敗ケースが成功ケースと同じ数以上であることを確認
- TDD プロトコル（PLAN → RED → GREEN → REFACTOR）が正確に従われることを認識
- 各フェーズ後にプロジェクトのテストコマンドを実行し、テスト結果（FAIL/PASS）を明示的に報告
- 各テストケースに Given/When/Then 形式のコメントを使用
- 変更をスキップまたはバッチ処理しない

## 【TDDの基本原則】

### Kent Beck によるテスト駆動開発（TDD）ルール

#### コア TDD サイクル - 必須実行

1. **Red（レッド）**: 小さな機能の増分を定義する1つの失敗するテストを書く
   - **必須**: プロジェクトのテストコマンドを即座に実行してテストが失敗することを確認
   - **禁止**: 実行前に複数のテストを書くこと
   - **禁止**: このステップの前にプロダクションコードを書くこと

2. **Green（グリーン）**: テストを通すために必要な最小限のコードを実装する
   - **必須**: プロジェクトのテストコマンドを即座に実行してテストが成功することを確認
   - **禁止**: 現在のテストを通すために必要以上のコードを書くこと

3. **Refactor（リファクタリング）**: テストを通したままコード構造を改善する
   - **必須**: 各リファクタリング変更の後にプロジェクトのテストコマンドを実行
   - **禁止**: テストが失敗している状態でリファクタリングすること

**原則**: 一度に1つのアトミックな変更を行う。TDD ルールに違反した場合、停止して適切にサイクルを再開すること。

### テスト計画フェーズ - RED の前に必須

最初の失敗するテストを書く前に、包括的なテスト計画を作成してください：

1. **テスト観点表**: 以下をカバーする Markdown 表を作成:
   - **同値分割**: 有効および無効な入力範囲
   - **境界値分析**: 0、最小値、最大値、±1、空、NULL
   - **テストカテゴリ**: 正常ケース、エラーケース、境界ケース、無効な型/形式、外部依存の失敗

2. **テストカバレッジ要件**:
   - **必須**: 成功ケースと同じ数以上の失敗ケースを含める
   - **必須**: すべての例外タイプとエラーメッセージをカバー
   - **必須**: 境界値をテスト（0、min、max、±1、空、NULL）
   - **必須**: 無効な型と不正な形式の入力をテスト
   - **必須**: 外部依存の失敗をテスト（該当する場合）
   - **目標**: 100% ブランチカバレッジを達成

3. **テストケース構造**:
   - 各テストケースに **Given/When/Then** 形式のコメントを使用
   - 前提条件（Given）、アクション（When）、期待される結果（Then）を明確に記述
   - **テスト名**: 動作を説明する意味のある名前を使用（例: `shouldSumTwoPositiveNumbers`、`shouldThrowErrorWhenInputIsNull`）
   - **テスト失敗メッセージ**: テストが失敗した場合、明確で情報豊富なエラーメッセージを提供する

4. **テスト計画の実行**:
   - テスト観点表を Markdown 形式で提示
   - 実装前に欠けているテスト観点を特定
   - テストを書く際に表に体系的に従う（TDD サイクルごとに一度に1つのテスト）
   - **テスト計画の完了状況を追跡・報告**: 
     - 各テストケースの実装状況を記録（未実装/実装中/完了）
     - 各TDDサイクル完了後に、完了したテストケース数 / 総テストケース数、完了率（%）を報告
     - 現在のテストケース、次のテストケース、残りのテストケースを明示
   - **完了確認**: すべてのテストケースが完了したことを確認してから次の機能に進む
   - すべてのテスト完了後、テスト実行コマンドとカバレッジ測定方法を文書化

**テスト観点表フォーマット例**:
```markdown
| カテゴリ | テストケース | 入力 | 期待される結果 | 優先度 |
|----------|-------------|------|----------------|--------|
| 正常     | 有効な入力   | 有効な値 | 成功 | 高 |
| 境界     | 最小値      | Min | 成功 | 高 |
| 境界     | 最大値      | Max | 成功 | 高 |
| 境界     | Min-1      | Min-1 | エラー | 高 |
| 境界     | Max+1      | Max+1 | エラー | 高 |
| エラー   | 無効な型    | 誤った型 | エラー | 高 |
| エラー   | 空の入力    | "" | エラー | 高 |
| エラー   | NULL入力   | null | エラー | 高 |
```

## 【実行プロセス】

### TDD 実行プロトコル - ステップバイステップ

**すべての TDD サイクルは以下の正確な順序に従う必要があります:**

**PLAN フェーズ**: テスト計画フェーズ（上記セクション）を参照してください。

1. **RED フェーズ**:
   ```bash
   # テスト計画に基づいて正確に1つのテストを書く
   echo "[テスト計画から特定の動作]に対する単一の失敗するテストを書く"
   echo "Given/When/Then 形式のコメントを使用"
   
   # 必須: プロジェクトのテストコマンドを使って即座にテストを実行
   # 例: npm test, cargo test, go test, pytest など（プロジェクトに応じて適切なコマンドを使用）
   
   # 検証: テストは期待されるエラーで失敗する必要がある
   echo "✓ テストが期待通り失敗することを確認"
   ```

2. **GREEN フェーズ**:
   ```bash
   # 最小限の実装を書く
   echo "テストを通すための最小限のコードを書く"
   
   # 必須: 即座にテストを実行
   # 例: npm test, cargo test, go test, pytest など（プロジェクトに応じて適切なコマンドを使用）
   
   # 検証: テストは成功する必要がある
   echo "✓ テストが成功することを確認"
   ```

3. **REFACTOR フェーズ**（オプション）:
   ```bash
   # 1つの改善を行う
   echo "リファクタリング [特定の改善]"
   
   # 必須: 即座にテストを実行
   # 例: npm test, cargo test, go test, pytest など（プロジェクトに応じて適切なコマンドを使用）
   
   # 検証: すべてのテストがまだ通る必要がある
   echo "✓ すべてのテストがまだ通ることを確認"
   ```

**繰り返し**: テスト計画の次のテストのためにステップ1に戻る

**テスト実行**: 各フェーズ後、長いテストを除いてすべてのテストを毎回実行してください。これにより、既存の機能が壊れていないことを確認できます。

**完了時**: すべてのテスト完了後、テスト実行コマンドとカバレッジ測定方法を文書化

### バグ修正時のTDDアプローチ

バグを修正する際は、以下の順序で進めてください：

1. **APIレベルの失敗テスト**: まず、バグを再現するAPIレベルの失敗テストを書く
2. **最小限の失敗テスト**: 次に、問題を再現する最小限のテストを書く
3. **両方のテストを通す**: 両方のテストが通るように修正する

このアプローチにより、バグが完全に修正され、回帰が防止されます。

## 【開発中の原則】

### 普遍的なコード品質標準

- 重複を徹底的に排除
- 命名を通じて意図を明確に表現
- 関数/メソッドを小さく焦点を絞った状態に保つ（プロジェクトの典型的なサイズに適応）
- 機能する最もシンプルなソリューションを使用
- テストが合格しているときのみリファクタリング
- **依存関係を明示的にする**: 関数やクラスの依存関係を明確に表現する
- **状態と副作用を最小化**: 可能な限り状態を減らし、副作用を避ける
- プロジェクトの標準に従って適切なドキュメントを追加
- プロジェクトのエラーハンドリングとログ規約に従う
- プロジェクトのアーキテクチャパターンと設計原則を尊重

### KISS 原則 - 必須実施

**Keep It Simple, Stupid（シンプルに保て、バカ）** - 複雑さの厳格な回避

#### KISS 実施ルール

- **禁止**: 不必要な機能追加、過剰エンジニアリング、時期尚早な最適化
- **必須**: 本質的な問題のみに焦点を当て、最小限の実装で解決
- **違反の結果**: 複雑さの兆候が現れた場合、即座に設計をレビュー

#### 複雑さ防止チェックリスト

機能を実装する前に以下を問う：

1. **これはコアの問題を解決するために絶対に必要か？**
2. **100行ではなく10行で実装できるか？**
3. **要求されていない機能を追加していないか？**
4. **初心者が30秒でこのコードを理解できるか？**

#### KISS 違反（禁止）

- シンプルな設定のための JSON/XML 設定ファイル
- 単一実装のための抽象ファクトリー
- シンプルなデータのための複雑なクラス階層
- シンプルな関数で十分なときの高度なパターン
- 1つで十分なときの複数の出力形式
- 基本機能のための広範なオプションメニュー
- シンプルなスクリプトのためのフレームワーク重視のソリューション

#### KISS コンプライアンス（必須）

- 1つのことをうまく行う単一目的の関数
- 最初は最小限の実行可能な実装
- 複雑なクラスの代わりにプレーンオブジェクト
- レイヤー化された抽象化の代わりに直接的なソリューション
- ハードコードされた妥当なデフォルト
- 詳細な分析よりもシンプルなエラーメッセージ

## 【リファクタリング・コミット】

### Tidy First アプローチ

- **構造的変更**: 動作を変更せずにコードを再配置（リネーム、抽出、移動）
- **動作的変更**: 実際の機能を追加または変更
- 同じコミットで構造的変更と動作的変更を混在させない
- 両方が必要な場合は常に構造的変更を先に行う
- テストを実行して構造的変更が動作を変更しないことを検証

### リファクタリングガイドライン

- リファクタリングはテストが合格しているときのみ行う（Greenフェーズ）
- **確立されたリファクタリングパターンとその正式な名前を使用**（例: Extract Method、Rename Variable、Move Methodなど）
- 一度に1つのリファクタリング変更を行う
- 各リファクタリングステップの後にテストを実行する
- 重複の削除や明確性の向上を優先する

### コミット基準

TDDサイクル内でのコミットは、以下の条件を満たす場合のみ行います：

1. すべてのテストが合格
2. すべてのコンパイラ/リンターの警告が解決
3. 変更が単一の論理ユニットを表す
4. 構造的変更と動作的変更を分離（Tidy First原則に従う）
5. AI生成コードの帰属や自動生成マーカーを含めない

**コミット頻度**: 小さく頻繁なコミットを推奨します。大きな、まれなコミットよりも、小さな、頻繁なコミットの方がレビューしやすく、問題の特定も容易です。

**コミットメッセージ**: コミットメッセージの形式、規約、レビューについては、プロジェクトにGit/GitHub運用エージェント（例: `.github/agents/custom.github.agent.md`）が存在する場合はそれを参照してください。存在しない場合は、プロジェクトのコミットメッセージ規約に従ってください。

## 【トラブルシューティング・運用】

### エラーハンドリングとデバッグ

- テストが予期せず失敗した場合、エラーメッセージを注意深く分析
- トラブルシューティングにはプロジェクトのデバッグツールと規約を使用
- 行き詰まった場合、最後の動作状態に戻り、より小さなステップを踏む
- テスト環境と依存関係が正しいことを常に確認
- プロジェクトのエラーハンドリングパターンとログ標準に従う

### コミュニケーションガイドライン

- 各 TDD サイクル完了後に進捗を報告（テスト計画の完了状況は「テスト計画の実行」セクションを参照）
- プロジェクト要件の文脈で技術的決定を説明
- プロジェクト固有の詳細が不明な場合は明確化を求める
- プロジェクト標準からの逸脱に対してコンテキストを提供
- プロジェクトチームの好みに合わせてコミュニケーションスタイルを適応

**覚えておいてください: ソフトウェア問題の90%は、典型的な「エンタープライズ」複雑さの10%で解決できます。**

## 参照ドキュメント

プロジェクトに以下のドキュメントが存在する場合は参照してください：

- **Git/GitHub運用エージェント**（例: `.github/agents/custom.github.agent.md`）: コミットメッセージのレビュー、コミット履歴の整理に関する詳細
- **リポジトリガイドライン**（例: `AGENTS.md`、`README.md`）: コミットとプルリクエストガイドライン、プロジェクトの運用ルール
- **コーディング規約**（例: `docs/dev/CODING_STANDARDS.md`、`docs/CODING_STANDARDS.md`）: コーディングスタイル、命名規則、ベストプラクティス

**注意**: これらのドキュメントが存在しない場合は、プロジェクトの既存コードパターンと規約を確認し、それに従ってください。

## Examples

### 例1: 新機能の実装

```
tdd-skillスキルを使用して、新しい関数`calculateTotal`を実装してください。テスト観点表を作成し、Red-Green-Refactorサイクルに従って実装してください。
```

### 例2: バグ修正

```
tdd-skillスキルを使用して、バグを修正してください。まずAPIレベルの失敗テストを書き、次に最小限の失敗テストを書いてから修正してください。
```

### 例3: リファクタリング

```
tdd-skillスキルを使用して、既存のコードをリファクタリングしてください。すべてのテストが通っていることを確認しながら、Tidy Firstアプローチに従ってください。
```

## Guidelines

### TDDサイクルの厳密な遵守

- 一度に1つのアトミックな変更のみを行う
- 各フェーズ後に必ずテストを実行する
- テストが失敗している状態でリファクタリングしない
- TDDルールに違反した場合は、停止して適切にサイクルを再開する

### テスト計画の重要性

- 実装前に必ず包括的なテスト計画を作成する
- 失敗ケースが成功ケースと同じ数以上であることを確認する
- テスト計画の完了状況を追跡・報告する
- すべてのテストケースが完了してから次の機能に進む

### KISS原則の徹底

- 複雑さを避け、シンプルなソリューションを選択する
- 不必要な機能追加や過剰エンジニアリングを避ける
- 本質的な問題のみに焦点を当てる

