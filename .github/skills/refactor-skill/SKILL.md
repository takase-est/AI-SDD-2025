---
name: refactor-skill
description: |
  過剰エンジニアリングを避けつつ、可読性・保守性・パフォーマンスに焦点を当てた改善機会を特定するコードリファクタリングスキル。
  このスキルは、コードのコンテキストを分析し、リファクタリングの機会を特定するために使用します。
  既存の動作を維持しながら、可読性、保守性、パフォーマンスを向上させる提案を提供します。
---

# コードリファクタリングスキル

このスキルは、コードのコンテキストを分析し、リファクタリングの機会を特定します。過剰エンジニアリングや不必要な複雑さの導入を避けながら、可読性、保守性、パフォーマンスを向上させる提案を提供します。

## 分析のアプローチ

### コンテキストの選択

現在のコンテキスト（例：アクティブな GitHub Issue、現在の git status diff、進行中のタスク）に基づいて候補コードを選択してください。

**重要な原則:**
- 明示的な指示がない限り、リポジトリ全体をスキャンせず、コンテキスト的に関連する部分のみに分析を制限してください
- 既存の動作を維持しながら、改善機会を特定してください

### 分析の焦点

以下の観点からコードを分析してください：

1. **可読性**: コードが理解しやすいか、意図が明確か
2. **保守性**: 変更が容易か、拡張性があるか
3. **パフォーマンス**: パフォーマンスのボトルネックがないか
4. **一貫性**: プロジェクトのコーディング規約に準拠しているか

## リファクタリング原則

すべての提案は以下の原則に従う必要があります：

### SOLID原則

- **単一責任の原則 (Single Responsibility Principle)**: 各クラスや関数は単一の責任を持つべき
- **オープン・クローズドの原則 (Open-Closed Principle)**: 拡張に対して開いており、修正に対して閉じているべき
- **リスコフの置換原則 (Liskov Substitution Principle)**: 派生クラスは基底クラスと置き換え可能であるべき
- **インターフェース分離の原則 (Interface Segregation Principle)**: クライアントが使用しないメソッドに依存すべきではない
- **依存性逆転の原則 (Dependency Inversion Principle)**: 高レベルのモジュールは低レベルのモジュールに依存すべきではない

### DRY (Don't Repeat Yourself)

- 繰り返しを避け、共通の機能は再利用可能な形で抽出する
- 重複コードを特定し、適切な抽象化を提案する

### YAGNI (You Aren't Gonna Need It)

- 必要になるまで実装しない
- 将来の要件を想定した過剰な抽象化を避ける
- 現在の要件に焦点を当てる

## 出力フォーマット

リファクタリング提案は以下の形式で提供してください：

### 1. 要約

改善候補の箇条書きリストを提供してください。各候補には以下を含めてください：

- **場所**: ファイルパス、行番号、関数/クラス名
- **カテゴリ**: 可読性、保守性、パフォーマンス、一貫性など
- **期待される利点**: 改善により得られる具体的な利点
- **おおよそのリスク**: 変更によるリスクレベル（低/中/高）

### 2. 詳細

各候補について、以下の情報を提供してください：

- **現在の状態**: 現在のコードの状態の説明
- **問題点**: 特定された問題や改善の機会
- **関連する原則**: 適用されるSOLID原則、DRY、YAGNIなど
- **提案される変更**: 具体的な変更内容の説明
- **期待される影響**: 変更による影響（可読性、保守性、パフォーマンスへの影響）

### 3. ミニ Diff（オプション）

最小限の抜粋と例示的な diff を提供してください。

**重要な制約:**
- ファイル全体や大規模な再設計は避ける
- 最小限の unified diff スニペットを例示する
- 有用な場合は、以下を明示的に指定してください：
  - ファイルパス
  - 関連する Issue 番号
  - diff hunk の場所

### 4. 推奨テスト

安全性を検証するために追加または強化すべきテストケースまたはシナリオを提案してください。

- リグレッションテストの説明
- 新しい機能のテストケース
- エッジケースのテスト

## 禁止事項

以下の行為は避けてください：

- **ファイル全体の再投稿または書き換え**: 変更が必要な部分のみに焦点を当てる
- **最終的な権威あるコードの提示**: 提案レベルにとどめ、実装の選択肢を提示する
- **大規模なアーキテクチャの再設計**: 明示的に要求されない限り、大規模な変更は避ける
- **正当化されない抽象化**: 過剰な抽象化や時期尚早な最適化を避ける

## 注意事項

### Diff スニペットについて

- Diff スニペットは例示的なものであり、直接適用するための最終的なコードではありません
- 実装前に必ずレビューとテストを行ってください

### リスク管理

提案が既存の動作を変更する可能性がある場合は、以下を含めてください：

- **リスク**: 変更による潜在的なリスク
- **軽減策**: リスクを軽減する方法（例：リグレッションテストの説明を追加）

## Examples

### 例1: 重複コードのリファクタリング

```
refactor-skillスキルを使用して、src/utils/csvParser.tsとsrc/utils/jsonParser.tsの重複コードを特定し、共通の処理を抽出する提案をしてください。
```

### 例2: 可読性の改善

```
refactor-skillスキルを使用して、src/components/BookForm.tsxの可読性を改善する機会を特定してください。SOLID原則に基づいて提案してください。
```

### 例3: パフォーマンスの最適化

```
refactor-skillスキルを使用して、src/App.tsxのパフォーマンスボトルネックを特定し、改善提案をしてください。YAGNI原則を考慮してください。
```

### 例4: コンテキストに基づく分析

```
現在のgit diffを分析して、refactor-skillスキルを使用してリファクタリングの機会を特定してください。変更されたファイルのみに焦点を当ててください。
```

## Guidelines

### コンテキストの理解

- 現在のタスクやIssueのコンテキストを理解してから提案してください
- 関連するファイルやモジュールの関係性を考慮してください
- プロジェクトのコーディング規約やアーキテクチャパターンを尊重してください

### 段階的な改善

- 一度にすべてを変更しようとせず、段階的な改善を提案してください
- 優先順位を明確にし、影響の大きい改善から順に提案してください

### テストの重要性

- すべてのリファクタリング提案には、適切なテストの追加を推奨してください
- 既存のテストが通ることを確認してください
- リグレッションテストを追加することを推奨してください

### コミュニケーション

- 提案の意図と利点を明確に説明してください
- リスクと軽減策を明確に提示してください
- 実装の選択肢がある場合は、それぞれのメリット・デメリットを説明してください

